/** The MIT License (MIT) Copyright(c) 2016 Maxim V.Tsapov */
import { FIELD_TYPE, DATA_TYPE, ITEM_STATUS } from "./const";
import { IFieldInfo } from "./int";
import { ERRS, STRS } from "../lang";
import { Utils } from "../utils/utils";
import { IIndexer, IValidationInfo } from "../int";


const utils = Utils, checks = utils.check, strUtils = utils.str;

function fn_toArray(index: IIndexer<IValidationInfo>): IValidationInfo[] {
    const keys = Object.keys(index), result: IValidationInfo[] = [];
    for (let i = 0, len = keys.length; i < len; i += 1) {
        result.push(index[keys[i]]);
    }
    return result;
}


export class Validations {
    private static _dtRangeToDate(str: string) {
        let dtParts = str.split("-");
        let dt = new Date(parseInt(dtParts[0], 10), parseInt(dtParts[1], 10) - 1, parseInt(dtParts[2], 10));
        return dt;
    }
    private static checkNumRange(num: number, range: string): string[] {
        let errors: string[] = [], rangeParts = range.split(",");
        if (!!rangeParts[0]) {
            if (num < parseFloat(rangeParts[0])) {
                errors.push(utils.str.format(ERRS.ERR_FIELD_RANGE, num, range));
            }
        }
        if (!!rangeParts[1]) {
            if (num > parseFloat(rangeParts[1])) {
                errors.push(utils.str.format(ERRS.ERR_FIELD_RANGE, num, range));
            }
        }
        return errors;
    }
    private static checkDateRange(dt: Date, range: string): string[] {
        let errors: string[] = [], rangeParts = range.split(",");
        if (!!rangeParts[0]) {
            if (dt < Validations._dtRangeToDate(rangeParts[0])) {
                errors.push(utils.str.format(ERRS.ERR_FIELD_RANGE, dt, range));
            }
        }
        if (!!rangeParts[1]) {
            if (dt > Validations._dtRangeToDate(rangeParts[1])) {
                errors.push(utils.str.format(ERRS.ERR_FIELD_RANGE, dt, range));
            }
        }
        return errors;
    }
    static checkField(fieldInfo: IFieldInfo, value: any, isNew: boolean): string[] {
        let res: string[] = [];

        const isNullVal = (value === null || (checks.isString(value) && !value));

        if (isNullVal && !fieldInfo.isNullable && !fieldInfo.isReadOnly) {
            if (!(isNew && fieldInfo.isAutoGenerated)) {
                res.push(ERRS.ERR_FIELD_ISNOT_NULLABLE);
            }
        }

        if (isNullVal)
            return res;

        switch (fieldInfo.dataType) {
            case DATA_TYPE.None:
                break;
            case DATA_TYPE.Guid:
                if (!checks.isGuid(value)) {
                    res.push(strUtils.format(ERRS.ERR_FIELD_WRONG_TYPE, value, "Guid"));
                }
                break;
            case DATA_TYPE.String:
                if (!checks.isString(value)) {
                    res.push(strUtils.format(ERRS.ERR_FIELD_WRONG_TYPE, value, "String"));
                }
                if (fieldInfo.maxLength > 0 && value.length > fieldInfo.maxLength) {
                    res.push(strUtils.format(ERRS.ERR_FIELD_MAXLEN, fieldInfo.maxLength));
                }
                if (!!fieldInfo.regex) {
                    const reg = new RegExp(fieldInfo.regex, "i");
                    if (!reg.test(value)) {
                        res.push(strUtils.format(ERRS.ERR_FIELD_REGEX, value));
                    }
                }
                break;
            case DATA_TYPE.Binary:
                if (!checks.isArray(value)) {
                    res.push(strUtils.format(ERRS.ERR_FIELD_WRONG_TYPE, value, "Array"));
                }
                if (fieldInfo.maxLength > 0 && value.length > fieldInfo.maxLength)
                    res.push(strUtils.format(ERRS.ERR_FIELD_MAXLEN, fieldInfo.maxLength));
                break;
            case DATA_TYPE.Bool:
                if (!checks.isBoolean(value))
                    res.push(strUtils.format(ERRS.ERR_FIELD_WRONG_TYPE, value, "Boolean"));
                break;
            case DATA_TYPE.Integer:
            case DATA_TYPE.Decimal:
            case DATA_TYPE.Float:
                if (!checks.isNumber(value))
                    res.push(strUtils.format(ERRS.ERR_FIELD_WRONG_TYPE, value, "Number"));
                if (!!fieldInfo.range) {
                    Validations.checkNumRange(Number(value), fieldInfo.range).forEach((err) => {
                        res.push(err);
                    });
                }
                break;
            case DATA_TYPE.DateTime:
            case DATA_TYPE.Date:
                if (!checks.isDate(value))
                    res.push(strUtils.format(ERRS.ERR_FIELD_WRONG_TYPE, value, "Date"));
                if (!!fieldInfo.range) {
                    Validations.checkDateRange(value, fieldInfo.range).forEach((err) => {
                        res.push(err);
                    });
                }
                break;
            case DATA_TYPE.Time:
                if (!checks.isDate(value))
                    res.push(strUtils.format(ERRS.ERR_FIELD_WRONG_TYPE, value, "Time"));
                break;
            default:
                res.push(strUtils.format(ERRS.ERR_PARAM_INVALID, "dataType", fieldInfo.dataType));
        }

        return res;
    }
    static distinct(vals: IValidationInfo[]): IValidationInfo[] {
        if (!vals)
            return [];

        const index: IIndexer<IValidationInfo> = {};
        vals.forEach((val) => {
            const name = !val.fieldName ? "*" : val.fieldName;
            let test = index[name];
            if (!!test) {
                test.errors = test.errors.concat(val.errors);
            }
            else {
                index[name] = val;
            }
        });

        return fn_toArray(index);
    }
}
